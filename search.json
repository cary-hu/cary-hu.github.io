[{"title":"合成复用原则(Composite Reuse Principle)","url":"/Design%20Pattern/CRP/","content":"尽量使用对象的组合，而不是继承来达到复用的目的，类与类之间的关系应该是has-a而不是is-a。\n优点\n\n降低主类的复杂度\n\n示例\n现有一个银行卡类的设计需求，简单分析后，将代码设计如下：\npublic interface ICard&#123;    string Id &#123; get; set &#125;    void Withdraw();    void Deposit();    void Overdraw();&#125;public class MyCard : ICard&#123;    public void Withdraw()    &#123;        // do something    &#125;    public void Deposit()    &#123;        // do something    &#125;    public void Overdraw()    &#123;        // do something    &#125;&#125;\n如此设计，我们办理的所有卡都将具有这个功能，此时使用了继承关系。为了更灵活的拥有各种功能，可以分别设立储蓄卡和信用卡两种，并拥有银行卡来对衙门进行聚合使用，此时采用了合成复用的原则：\npublic interface ICard&#123;    public string Id &#123; get; set &#125;    public SaveCard saveCard();    public CreditCard creditCard();&#125;public class SaveCard&#123;    public void Withdraw()    &#123;        // do something    &#125;    public void Deposit()    &#123;        // do something    &#125;&#125;public class CreditCard&#123;    public void Overdraw()    &#123;        // do something    &#125;&#125;public class MyCard : ICard&#123;    &#125;","categories":["设计模式"]},{"title":"依赖倒置原则(Dependency Inversion Principle(DIP))","url":"/Design%20Pattern/DIP/","content":"该原则的定义为：1. 上层模块不应该依赖于底层模块，他们应该依赖于抽象。 2. 抽象不应该依赖于细节，细节应该依赖于抽象\n优点\n\n减少类之间的耦合性\n提高系统的稳定性\n降低并行开发引起的风险\n提高代码的可读性和可维护性\n\n难点\n\n设计之初就应该将整体的框架想好，提前抽象出应当抽象的东西\n\n示例\n现有一个输出消息的需求，要求不同设备能输出不同的消息，那么给出如下代码：\npublic class DeviceA&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceA&quot;);    &#125;&#125;public class DeviceB&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceB&quot;);    &#125;&#125;public class ComputerControl()&#123;    public void ConsoleLog(DeviceA device)    &#123;        device.ConsoleLog();    &#125;    public void ConsoleLog(DeviceB device)    &#123;        device.ConsoleLog();    &#125;&#125;\n这样设计的话，设计之初可能没什么大的问题，但随着设备的增加，每次增加设备都要在电脑控制台进行性的实现，使我们的代码变得愈发的臃肿，难以维护，这里可以发现，ComputerControl这个类是一个高级模块，而DeviceA、DeviceB都是细节实现类，这样的设计不符合依赖倒置的设计原则，于是将代码做出如下修改：\npublic interface IConsoleLog&#123;    void ConsoleLog();&#125;public class DeviceA : IConsoleLog&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceA&quot;);    &#125;&#125;public class DeviceB : IConsoleLog&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceB&quot;);    &#125;&#125;public class ComputerControl()&#123;    public void ConsoleLog(IConsoleLog device)    &#123;        device.ConsoleLog();    &#125;&#125;\n将代码修改成这样之后，以后再加设备，仅需增加该设备的具体实现，让他实现ConsoleLog的接口即可，这里让ComputerControl依赖于抽象IConsoleLog，其他的设备依赖于该抽象，以后的拓展和维护变得更加的方便了。\n图例\n\n","categories":["设计模式"]},{"title":"DRY原则(Don't repeat yoursel)","url":"/Design%20Pattern/DRY/","content":"DRY原则是指在编程过程中不写重复的代码，将公共的部分抽象出来，封装成一个基础类，在使用的时候再进行调用。\n优点\n\n降低了代码的耦合度\n提高代码的灵活性、健壮性以及可读性，方便了后期的维护和修改\n\n难点\n\n抽象需要恰到好处，过多的抽象可能会导致简单的代码复杂化\n可能会导致降低代码的可读性\n\n示例\n现有一个根据不同的url获取不同路径的需求，分析后设计代码如下：\npublic string GetBody(string url)&#123;    String body = &quot;&quot;;    if (url.Equals(&quot;/index.html&quot;))     &#123;        body = &quot;./public/index.html&quot;;    &#125;    if (url.Equals(&quot;/css/index.css&quot;))    &#123;        body = &quot;./public/css/index.html&quot;    &#125;    if (url.Equals(&quot;/js/index.js&quot;))    &#123;        body = &quot;./public/js/index.html&quot;;    &#125;    return body;&#125;\n当情况比较多之后，这么一个简单的功能的代码量就会变得非常庞当，而且更麻烦的是维护的过程中，如果文件夹位置改变或者文件名改动，就会牵一发而动全身，如果某个位置漏改了，就会引起程序出错。即便改完所有地方，也是一件挺麻烦的事。所以我对代码进行抽象、修改。修改之后 代码如下：\npublic string GetBodyFunction(url)&#123;    var body = new StringBuilder();    return body.AppendFormat(&quot;./public&#123;0&#125;&quot;,url);&#125;public string GetBody(string url)&#123;    String body = GetBodyFunction(url);    return body;&#125;\n图例\n\n","categories":["设计模式"]},{"title":"接口隔离原则(Interface Segregation Principle(ISP))","url":"/Design%20Pattern/ISP/","content":"通俗的来说，就是一个接口里不要放很多方法，这样会显得这个接口臃肿不堪，接口应当尽量细化，一个接口对应一个功能模块，同时接口里的方法应当尽可能的小，使接口更加轻便灵活。\n优点\n\n避免接口污染\n提高灵活性\n提供定制服务\n实现了高内聚\n\n难点\n\n设计时必须根据实际需要实际考虑，没有一个通用的办法\n\n示例\n举一个很常见的例子，现在有一个需求，我们需要一个接口用来定义美女，给出的要求：美女包括面貌、身材和气质，那么根据需求定义如下接口：\npublic interface IBeauty&#123;    public bool IsLookNice(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity is look nice or not    &#125;    public bool IsNiceFigure(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has nice figure or not    &#125;    public bool GreatTemperament(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has great temperament or not    &#125;&#125;\n看起来代码如此设计并没有什么问题，但是现实生活中不乏有长得一般，但是气质很好的气质美女，那么上面的接口就不再适用，于是我们将代码做如下修改：\npublic interface ILookBeauty&#123;    public bool IsLookNice(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity is look nice or not    &#125;    public bool IsNiceFigure(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has nice figure or not    &#125;&#125;public interface ITemperamentBeauty&#123;    public bool GreatTemperament(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has great temperament or not    &#125;&#125;\n然后通过这两个接口的组合，便能完成之前提到的需求。\n图例\n\n","categories":["设计模式"]},{"title":"迪米特法则(Law of Demeter(LD))","url":"/Design%20Pattern/LD/","content":"迪米特法则的意义在于降低类之间的耦合，它要求一个对象应该对其他对象有最少的了解（也就是说，设计的每个类、每个功能点应该相对独立，互相之间不存在或者说很少有依赖关系）。在实践中，通常采用只暴露必须要暴露的方法，来保证迪米特法则，其他一些不必要暴露的方法，全都设置为私有方法，不允许外部类使用和查看。以此降低两个类之间的耦合。\n优点\n\n提高了类的复用性\n降低了类变更的风险\n\n难点\n\n采用该法则应当适度，解耦是有限度的，要根据经验来避免过犹不及。\n\n示例\n现有一个场景，一个男人要煮咖啡，现有两个类，分别是咖啡机和这个男人，代码如下：\npublic class CoffeeMachine&#123;    public void AddCoffeeBean()    &#123;        // do something    &#125;    public void AddWater()    &#123;        // do something    &#125;    public void StartMachine()    &#123;        // do something    &#125;&#125;public class Man&#123;    public void MakeCoffee()    &#123;        CoffeeMachine coffeeMachine = new CoffeeMachine()&#123; &#125;;        coffeeMachine.AddCoffeeBean();        coffeeMachine.AddWater();        coffeeMachine.StartMachine();    &#125;&#125;\n在以上代码中，男人对于咖啡机内部的方法了解过多，其实他并不用关注这些具体的过程，所以将代码进行优化：\npublic class CoffeeMachine&#123;    public void MakeCoffee()    &#123;        AddCoffeeBean();        AddWater();        StartMachine();    &#125;    private void AddCoffeeBean()    &#123;        // do something    &#125;    private void AddWater()    &#123;        // do something    &#125;    private void StartMachine()    &#123;        // do something    &#125;&#125;public class Man&#123;    public void MakeCoffee()    &#123;        CoffeeMachine coffeeMachine = new CoffeeMachine()&#123; &#125;;        coffeeMachine.MakeCoffee();    &#125;&#125;\n这样修改了之后，暴露给男人的接口变少，减少了男人类对咖啡机类的了解，降低了它们之间的耦合。\n","categories":["设计模式"]},{"title":"里氏替换原则(Liskov Substitution Principle(LSP))","url":"/Design%20Pattern/LSP/","content":"里氏替换原则是用来解决当父类代码改变，子类功能也会受到影响的问题。在设计类的时候，如果有继承关系，其子类必须实现父类的所有抽象方法，但是不可以重写父类的非抽象（已实现）方法，子类可以新增自己特有的方法，在实现抽象方法时，其形参必须比父类的形参更为宽松，但返回值子类必须比父类更为严格。（isA）\n优点\n\n增强了程序的健壮性、兼容性\n克服了继承中重写父类造成的可复用性变差的缺点\n降低了代码出错的可能性\n\n难点\n\n\n\n示例\n正方形到底是不是特殊的长方形~\npublic class Rectangle&#123;    private double width &#123;get; set; &#125;    private double height &#123;get; set; &#125;&#125;public class Square&#123;    private double side &#123;get; set; &#125;&#125;\n以此来看的话，正方形和长方形的结构完全不同，看起来正方形不应该是长方形的子类，所以长方形和正方形之间并不符合里氏替换原则，但是，将代码做如下修改：\npublic interface IPolygon&#123;    public double GetWidth();    public double GetHeight();&#125;public class Rectangle : IPolygon&#123;    private double width;    private double height;    public double GetWidth()    &#123;        return width;    &#125;    public void SetWidth(double width)    &#123;        this.width = width;    &#125;    public double GetHeight()    &#123;        return height;    &#125;    public void SetHeight(double height)    &#123;        this.height = height;    &#125;&#125;public class Square : IPolygon&#123;    private double side;    public double GetWidth()    &#123;        return this.GetSide();    &#125;    public void SetWidth(double width)    &#123;        this.SetSide(width);    &#125;    public double GetHeight()    &#123;        return this.GetSide();    &#125;    public void SetHeight(double height)    &#123;        this.SetSide(height);    &#125;    public double GetSide()    &#123;        return side;    &#125;    public void SetSide(double side)    &#123;        this.side = side;    &#125;&#125;\n图例\n\n","categories":["设计模式"]},{"title":"开放封闭原则(Open Closed Principle(OCP))","url":"/Design%20Pattern/OCP/","content":"对于类的设计来说，他应该是可以拓展的，但不应该可以进行修改，也就是说，对拓展是开放的，而对修改是封闭的。对拓展开放，意味着有新的需求或变化时，可以对现有代码进行拓展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以进行独立的工作，而不需要对类进行任何修改。而在设计类的时候要符合这个原则，只有依赖于抽象，实现开放封闭的核心思想就是抽象编程，而不是具体编程，因为抽象相对稳定，让类依赖于固定的抽象，所以对修改是封闭的，而通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过重写方法来改变其固有的行为，实现新的拓展方法，这是实施开放封闭原则的基本思路。\n优点\n\n代码可读性高，可维护性强\n单一类的逻辑简单，复用性强\n\n难点\n\n类的设计要做到完全对修改封闭，几乎是不可能完成的任务，视情况而定，不用强求。\n对设计类的人员要求较高，因为要考虑到以后所有有可能变化的因素，留下接口\n\n示例\n现有一个计算器的设计需求，要求实现加减乘除，最简单的实现：\npublic class Calculator&#123;    public double Add(double numberA,double numberB)    &#123;        return numberA + numberB;    &#125;    public double Minus(double numberA,double numberB)    &#123;        return numberA - numberB;    &#125;    public double Multiply(double numberA,double numberB)    &#123;        return numberA * numberB;    &#125;    public double Divide(double numberA,double numberB)    &#123;        return numberA / numberB;    &#125;&#125;\n这样的设计在使用初期可能会显得并没有什么问题，但如果现在加入了新的算法，将会导致程序员不得不对这个类进行修改，这就违反了我们的设计原则。于是，进行了如下修改：\npublic interface ICalculator&#123;    double GetResult(double numberA, double numberB);&#125;class Add : ICalculator&#123;    public double GetResult(double numberA, double numberB)    &#123;        return numberA + numberB;    &#125;&#125;...class Divide : ICalculator&#123;    public double GetResult(double numberA,double numberB)    &#123;        return numberA / numberB;    &#125;&#125;\n设计一个getResult的接口，需要不同的算法，就对他进行不同的实现，从而实现不对原类进行修改，只进行拓展，从而实现不同的需求，从而满足开放封闭原则。\n图例\n\n","categories":["设计模式"]},{"title":"设计模式","url":"/Design%20Pattern/Overview/","content":"设计模式是编程界的前辈们，根据自己对面向对象程序编码开发的经验所总结出来的、解决特定问题的一系列套路，他并不是语法规定，而是一套用来提高提高代码复用率、可维护性、可读性、稳健性以及安全性的解决方案。\n\n本次学习基于：Design Patterns - Elements of Reusable Object-Oriented Software一书，该书由Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides四个人合著，他们四个人被称为Gang of Four，缩写为Gof。这本书介绍了23中设计模式，就是指GoF的23种设计模式。\n六大原则 SOLID\n所有的设计模式均遵循以下六个基本的设计原则：\n\n单一职责原则：Single responsibility principle(SRP)\n开放封闭原则: Open Closed Principle(OCP)\n里氏替换原则: Liskov Substitution Principle(LSP)\n迪米特法则: Law of Demeter(LD)\n接口隔离原则: Interface Segregation Principle(ISP)\n依赖倒置原则: Dependency Inversion Principle(DIP)\n\n另外，在平时的代码设计中，还涉及到其他的四个原则：\n\nDRY原则: Don’t repeat yourself\nYAGNI原则:  You aren’t gonna need it\n三次原则: Rule of three\n合成复用原则: Composite Reuse Principle\n\n总结\n三大设计模式\nGoF的23种设计模式一般分为三大类\n创建型模式\n\n工厂方法模式\n抽象工厂模式\n单例模式\n创建型模式\n原型模式\n\n结构型模式\n\n适配器模式\n外观模式\n享元模式\n组合模式\n装饰器模式\n代理模式\n桥接模式\n\n行为型模式\n\n策略模式\n状态模式\n职责链模式\n观察者模式\n模板方法模式\n命令模式\n备忘录模式\n迭代器模式\n调停者模式\n解释器模式\n访问者模式\n\n","categories":["设计模式"]},{"title":"三次原则(Rule of three)","url":"/Design%20Pattern/ROT/","content":"这个原则是用来解决DRY和YAGIN原则的矛盾的，就是只有当某个功能出现第三次的时候，才会将其进行抽象。这样，既不会出现太早的抽象化，也不会使代码变得更复杂。\n优点\n\n避免了耗费没必要的抽象化时间\n可以更准确的对某些功能进行抽象化\n\n示例\n对于一个数列来说，两个元素不足以看出规律：\n1 2\n但是当第三个元素出现的时候，其规律就变得清晰了起来：\n1 2 4\n","categories":["设计模式"]},{"title":"单一职责原则(Single responsibility principle(SRP))","url":"/Design%20Pattern/SRP/","content":"在设计一个类的时候，应该只有一个引起他变化的原因，且应只完成一个任务（职责），如果一个类有一个以上的职责，那么这些职责就耦合在了一起，这会导致设计出来的代码不够健壮，当某一个职责发生变化的时候，可能会影响到其他的职责，另外，如果多个职责耦合在一起，将会影响到这个类的复用性。\n优点\n\n降低类的复杂性，单个类只负责单一的职责，逻辑相比较于负责多职责的类简单\n提高类的可读性，提高代码的可维护性\n提高类的复用性\n降低代码变更带来的风险，修改某一个接口的功能的时候，降低该接口对其他接口功能的影响\n\n难点\n\n职责没有一个量化的标准，在划分单个类的职责时，需要从实际出发，以经验为准，对特定的项目进行特定的分析\n\n示例\n假设我现在在做一个学生信息管理系统，现有一个需求，要求提供修改学生基本信息的接口，于是我进行了如下设计：\nbool changeUserInfo(UserEntity student, string changeOption)&#123;    // do something&#125;\n该方法可以将changeOption中需要修改的参数，在函数体中进行逻辑处理，将其修改到student实体中，但是这样带来的问题就是，方法职责不清晰、不单一，较好的设计应该是，如果需要修改用户名，就调用修改用户名的API，需要修改家庭住址，就调用修改家庭住址的API，修改后的代码如下：\nbool changeUserName(string name)&#123;    // do something&#125;bool changeUserAddress(string address)&#123;    // do something&#125;\n如此设计，在后期的维护、修改、重构代码将会变得轻而易举，每个方法的职责清晰明确，开发难度也变低了。\n图例\n\n","categories":["设计模式"]},{"title":"YAGNI原则（You aren't gonna need it）","url":"/Design%20Pattern/YAGNI/","content":"除了最核心的功能，其他功能一概不要部署，这样来加快开发，他背后的指导思想，就是尽可能快，尽可能简单的让软件运行起来。\n优点\n\n开发速度快\n\n难点\n\n如何合理的降低抽象的层级，来实现低复杂度\n如何适度的接受非功能性的需求\n\n","categories":["设计模式"]},{"title":"Summary","url":"/Design%20Pattern/summary/","content":"通过这次对代码设计原则的学习，我了解到了在设计代码的时候，不能总是想到哪就写到哪，在开始写代码之前，需要有一个整体的流程，需要想好那些地方该抽象，那些地方需要冗余，否则，写出来的代码也会很繁琐，不够简洁。在设计代码的时候，既不能一味的追求代码满足全部的设计原则，也不能一点都不顾这些设计原则，要有一个自己拿捏的度，适量的使用这些原则，才能使自己的代码变得更加优美。\n在设计代码的时候，要时刻提醒自己，自己设计的代码一定要满足高内聚、低耦合这两个原则，并在之后的编码过程中进行实践，长此以往，写出来的代码必定不会太差。\n","categories":["设计模式"]},{"title":"秦岭 草甸","url":"/Tourism/Caodian%20Qinling/","content":"test\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["旅游","爬山"]},{"title":"嘉午台游记","url":"/Tourism/Jiawu%20Terrace/","content":"\n\n\n\n\n\n\n\n\n\n\n\n","categories":["旅游","爬山"]}]