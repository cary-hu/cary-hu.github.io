[{"title":"毕业后的同学聚会，让我哭了一宿","url":"/Article/%E6%AF%95%E4%B8%9A%E5%90%8E%E7%9A%84%E5%90%8C%E5%AD%A6%E8%81%9A%E4%BC%9A%EF%BC%8C%E8%AE%A9%E6%88%91%E5%93%AD%E4%BA%86%E4%B8%80%E5%AE%BF/","content":"有人说同学会是名利场，毕业后就不想再参加，在批判的背后，我们透过表象也可以看到，毕业几年后，人与人之间的差距越来越大。很多人疑问：“我们在大学时明明差不多，为什么他现在却比我厉害那么多？”其实明明差很多，只是你眼界太窄，没看到。\n\n文 | 怀左同学\n\n1 -\n\n学校单一的评判模式，掩盖了很多立体式的差距，所以当你只知道用学习成绩去衡量别人时，成绩再好点，你可能觉得自己天下无敌了。\n其实这就像和人打架，当你埋头苦练到可以开砖碎石，觉得信心满满然后去挑战对手时，却赫然发现了对方手里的AK47。\n明白了，原来我们的努力，一直不在一个层次上。当我的手上练出老茧时，你已经拥有了一支军队。\n活生生的例子，身边比比皆是。\n之前我在文章中提到了毕业后开公司的学长，因为他在大学时并不喜欢自己的专业，又常常逃课外出参加活动，所以学习成绩很一般。\n记得他创办文学社时，本专业还有一位学长阻止我参加：“那个人我知道，没什么真才实学，成绩也很烂，他就是为了赚你的社费。”\n但我还是去了，因为我很喜欢文学社的名字——“初雪”。那是我写作之路的开始，作为社长的他，经常给我批改文章，教我社会礼仪，带我和老师吃饭，还让我当上了第二届社长。\n他只比我大了一岁，但我有点怕他，也非常尊敬他。他和同龄人总是那么不一样，敢想敢做，在大三时，就成立了自己的团队，做报纸，出书，认识了很多名人。\n他说：读大学，成绩不是最主要的，找到自己的方向，把眼光放长远，踏踏实实把事情做好，这才是最重要的。\n他做了，自己创业，买房买车，红红火火。\n\n2 -\n\n细细想来，决定人与人之间差距的因素有很多，抛开我们不可控的家庭因素，对我们影响更多的，其实是我们的格局和眼界。\n这其实也是努力的一种表现，不是身体的瞎使劲，而是大脑的灵活运用。\n眼界决定境界，格局决定结局，我现在越来越相信这句话，因为不同层次的努力，直接导致了不同的结果。\n想起了以前在书本上看到的央视记者和一个西北放羊娃的对话。\n“你每天干什么？”“放羊。”“放羊为了什么？”“挣钱。”“挣了钱呢？”“娶媳妇。”“娶了媳妇呢？”“生娃。”“生了娃，让他干什么？”“放羊。”……\n当时我当笑话看的一段对话，现在再看，触目惊心，原来这也是现在很多在校大学生的写照。\n“你上大学是为了什么？”“找工作。”“找工作干什么？”“挣钱。”“挣了钱呢？”“买车买房娶媳妇”“娶了媳妇呢？”……“培养孩子上大学。”\n思维和认识上的差距，会决定我们的行动方向，也就是说，现在你和小伙伴同在一所高校，之后的几年，很可能你们的差距，是指数式的。\n他年薪百万时，你在备考第五次公务员。\n他忙着给员工发年终奖时，你在组织身边人抢几块钱的红包。\n曾经，你觉得，他不如你。\n\n3 -\n\n别人说，毕业五年后，你和同学的差距，天翻地覆。虽然我现在身边还没有年薪百万以上的同学，但量变而引起的质变，正在一点点发生。\n朋友圈有五千人，每天展现的，是各式人生。\n有人在国外攻读学位，有人的创业公司正在起步，有人成了蒸蒸日上的自媒体大咖，有人周游世界照片一张张发……\n当然，这只是一部分，还有更多的大学生在抱怨英语四级太难，抱怨宿舍氛围太差，抱怨没人陪着打王者，抱怨平时的假期太短。\n总是在追问读书的意义，总是在随大流东奔西走，恍恍惚惚，懒懒散散，四年其实很容易就过去了。\n再后来，就成了完全随大流的人生，差不多的工作，差不多的生活，直到某一天看到了远超自己的同学，尴尬地笑笑，然后回家吐槽：这世界真特么不公平！\n你根本不知道他读了几本书，不知道他为了目标可以多拼命，不知道他的特立独行，不知道他的卓识远见。你只看到了当时你们差不多，和后来的差好多。\n他把读书当成了每天的习惯，疯狂地汲取着各类知识；他清清楚楚地知道自己想要的什么，用你根本想象不到的努力在一直坚持着；他知道什么是长远利益，什么是格局和胸襟，他也许偏执，但他活成了你梦想中的样子。\n这样的人，他总失败，因为他一直在追求卓越；而你，总“成功”，因为你从来都没有投入斗争。\n直到你后来仰着头，都没有看清他的身影。\n· · ·\n未来的五到十年，你将被同学甩出老远，那么，现在的你，在做着什么？\n是不是在忙着玩手机，打游戏，睡懒觉，随大流，已经完全做好了被超越的准备，将所有的所有，解释为“不公平”三个字。\n挺好的，这就是你的一贯作风。\n想起了王小波笔下的那只特立独行的猪。\n“我倒是见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。”\n所以他怀念那只猪。\n","categories":["文艺","文章"]},{"title":"Just Sentence","url":"/Beautiful%20Sentence/Just-Sentence/","content":"\n我想重新认识你，从你叫什么名字开始。\n\n\n\n昼赏微云夜观星，醒亦思卿，寐也思卿。\n\n\n夕阳美如画，清风醉晚霞，温婉拥雅韵，墨色度芳华。\n\n\n我愿为你颠倒红尘，这是你我的命运。有一日，当你登临高峰，面向大海，你会看到一个云游四方的行僧。你的眼中有他，他却在回眸之间将你印入了心底。\n\n\n我裁一段星河以赠你好教你不逊色这人间错落烟火。\n\n\n南方有嘉木，北方有相思，嘉木风可催，相思不可断。\n人道海水深，不抵相思半，海水尚有涯，相思渺无畔。\n\n\n半生花开，半世花落。\n\n\n未若惊鸿轻挽髻，素雨落笺书云鬟。\n\n\n谁将岁月轻描淡写从此人生纸墨云烟。\n愿你千山暮雪海棠依旧不被岁月惊扰。\n\n\n静水流深，苍生踏歌。三生阴晴圆缺，一朝悲欢离合。\n\n\n为你明灯三千，为你花开满城。\n\n\n红叶可知书生意，落花不懂相思情。\n\n\n与时光皆薄凉，我与梨花共泪殇。\n\n\n三千繁华东流水，一梦长安终成灰。\n\n\n风吹起如花般破碎的流年，而你的笑容摇晃摇晃，成为我命途中最美的点缀，看天，看雪，看季节深深的暗影。\n\n\n浮生有梦三千场 穷尽千里诗酒荒。\n\n\n执子之手，陪你疯狂千生。深吻子眸，伴你万世轮回。\n\n\n经不住似水流年 逃不过此间少年。\n\n\n剑起星落流云殇，断情丝，了无憾。\n\n\n一朝春去红颜老 花落人亡两不知。\n\n\n原来姹紫嫣红开遍似这般都付与断井颓垣。\n\n\n我有一壶酒，足以慰风尘。醉步红尘里，笑谈世间人。\n\n\n愿余生鲜衣怒马 陪你看烈焰繁花。\n\n\n似曾相见便相知，相见何如不见时。安得与君相决绝，免教生死作相思。\n\n\n只是心里清楚的知道，再也不会热络的聊天到深夜，再也不会矫情到死阴晴不定。\n\n\n如果，你喜欢天上的星星，不一定非要摘下来，能天天看着他发光发亮，俺就心满意足啦。\n\n\n可惜我相貌平平，惊艳不了谁的岁月。\n\n\n越努力越进步越开心越自信,越懒惰越迷茫越焦虑越自卑。\n\n\n如果你不出去走走，你就会以为这就是世界——《天堂电影院》\n\n\n-你什么时候爱上她的？\n-当我以为我再也见不到她的时候——《搜索》\n\n\n我会回去，找到你，爱着你，娶了你，无悔的生活！——《赎罪》\n\n\n我等了三年，就是要等一个机会，我要争一口气，不是想证明我了不起，我只是要告诉别人，我失去的东西一定要拿回来——《英雄本色》\n\n\n既然为活命而工作，为什么又为工作卖命？——《黄金三镖客》\n\n\n她很崇拜他，他给了她一切，但却没给她时间——《哈利波特7》\n\n\n我们一路奋战 不是为了改变世界 而是为了不让世界改变我们——《 熔炉》\n\n\n当人们做不到一些事情的时候，他们就会对你说你也同样不能——《当幸福来敲门》\n\n\n黎叔很生气，后果很严重——《天下无贼》\n\n\n反贪腐是件大事，反，亡党！不反，亡国！难！——《建国大业》\n\n\n生命最可悲的是不能重来，生命最可贵的是不需要重来——《童梦奇缘》\n\n\n我知道我自己不够好，但是你应该等我，我值得你等——《敢死队》\n\n\nW：为什么你不再婚呢？ S：我的妻子已经死了。\nW：我知道，所以才说是再婚。 S：她已经死了——《心灵捕手》\n\n\n要么你就打包回家，要么你就继续战斗下去——《奔腾年代》\n\n\n一件事无论太晚，或是像我太早，都不会阻拦你成为你想成为的那个人。这个过程没有时间的期限，只要你想，随时都可以开始——《返老还童》\n\n\n我要和你做爱，不是一次两次，是一生一世——《美丽人生》\n\n\n曾经发生的事不可能忘记，只是想不起来而已——《千与千寻》\n\n\n以防再也见不到你,祝你早安,午安,晚安——《楚门的世界》\n\n\n我们会提出一个他无法拒绝的条件——《教父》\n\n\n有人的地方，就有江湖——《 笑傲江湖之东方不败》\n\n\n每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。——《东邪西毒》\n\n\n“用生命去换取图腾，那用什 么来换回这些年轻的生命！！”\n“骄傲！！” ——《赛德克巴莱》\n\n\n真正的帝王不是说我要杀了你，而是说我要赦免你——《辛德勒的名单》\n\n\n不行，说好的一辈子，差一年、一个月、一天、一个时辰，都不算一辈子！——《霸王别姬》\n\n\n为什么我就注定得伤心，就你可以说走就走！\n我也可以呀！我舍不得罢了！——《零摄氏度之春光再现》\n\n\n我想做的事情 你就算活到死都猜不透！——《四大名捕》\n\n\n没有人永远年轻，但永远有人正年轻着——《小时代》\n\n\n出来混的，迟早要还的——《无间道》\n\n\n不要忘了，这个世界穿透一切高墙的东西，它就在我们的内心深处，他们无法到达，也接触不到，这就是希望——《肖申克的救赎》\n\n\n有些人能清楚地听见自己内心的声音，并且遵循它而活。其中一些成了疯子，另一些成了传奇。——《燃情岁月》\n\n\n我所认为最深沉的爱，莫过于分开以后，我将自己活成了你的样子——《志明与春娇》\n\n\n我开始发现所有的东西都有了保质期，我开始怀疑有什么是不过期的——《重庆森林》\n\n\n人生总是这么苦么，还是只有童年苦？\n总是这么苦。——《这个杀手不太冷》\n\n\n周围的邻居不是开奔驰就是开宝马， 你要是开一日本车，你都不好意思跟人家打招呼——《大碗》\n\n\n人们往往用至诚的外表和虔敬的行为，掩饰一颗魔鬼般的心——《V字仇杀阵》\n\n\n你们！愿不愿意去换一个机会?用这么多苟活的日子，去换仅有的一个机会，那就是回到战场！——《勇敢的心》\n\n\n她犹如我的癌症，就像长在嘴边的烂疽一般。不去舔就不会恶化，但没有办法不去舔 ——《搏击俱乐部》\n\n\n人生就像一盒巧克力，你永远都不知道下一颗是什么口味——《阿甘正传》\n\n\n你可以说我是跑龙套的，但是你不可以说我是臭跑龙套的！——《喜剧之王》\n\n\n你这人最大的优点就是能在关键时刻大义灭亲，说翻脸就翻脸，稍加训练就能成立一恐怖组织，还绰绰有余——《不见不散》\n\n\n出来混，要讲信用。说了杀你全家，就一定要杀你全家——《古惑仔之人在江湖》\n\n\n你知道吗？风往哪个方向吹，草就要往那个方向倒。年轻的时候，我也曾经以为自己是风，可是最后遍体鳞伤，我才知道，原来我们都是草。——《艋舺》\n\n\n除了吃和睡，生命也许还有别的意义，不过我觉得没有就挺好——《加菲猫》\n\n\n东西你拿回去吧，我怕要了你一样之后就想要你更多——《最爱》\n\n\n上帝会把我们身边最好的东西拿走，以提醒我们得到的太多！——《四根羽毛》\n\n\n爱一个女孩子，与其为她的幸福而放弃她，不如留住她，为她的幸福而努力。 ——《水晶之恋》\n\n\n我不希望看到你流泪，除非是为了幸福。——《魂断蓝桥》\n\n\n基本的事不懂没关系，什么都懂才奇怪呢——《伦敦大道》\n\n\n都说人生无悔，那是赌气的话，如果真无悔，那该多无趣啊——《一代宗师》\n\n\n身体残疾不算残疾，心里残疾才是真正的残疾——《盲证》\n\n\n这么多年,牵着你的手,就象左手牵着右手没有感觉,但砍下去也会生疼。——《一声叹息》\n\n\n我甚至连他的一张照片都没有。他只活在我的记忆里。——《泰坦尼克号》\n\n\n人生下来的时候都只有一半，为了找到另一半而在人世间行走。有的人很幸运，很快就找到了。而有人却要找一辈子—《玻璃樽》\n\n\n别人的画 怎么可能找到自己呢？\n\n\n而你有自己的朗读者 而我 只是个摆渡人。\n\n\n我认识的女孩不完美 我也不完美 完美的是两个人适合在一起。\n\n\nyou are all my reasons.\n\n\n‌愿得韶华刹那 开得满树芳华。\n\n\n‌从今天起，你是木先生，我是玉夫人。木先生和玉夫人，我们永远不分离，好不好?\n\n\n‌忘川之水，在于忘情。\n\n\n‌你有没有爱过一个人，你有没有恨过一个人？\n\n\n‌一人之重，全天下人之轻。\n\n\n‌胜固欣荣，败也从容。\n\n\n愿意随我一同回家么，管你一日三餐，保你吃饱。\n\n\n‌锦衣雪华玉颜色 回眸一笑天下倾。\n\n\n‌终此一生，无需歉语，只因妾为掌中花，君为托花人，得君来归，不至花落人亡两不知，相守终有年，再无所求。\n\n\n‌我叫叶舟 一叶情障的叶 风雨同舟的舟。\n\n\n‌你若转身我便在地狱。\n\n\n‌陌上人如玉 公子世无双。\n\n\n‌万里江山，无上皇权，我与你共享。刀山火海，阴谋诡计，我与你共担。名川胜景，繁华盛世，我与你同游。有何可后悔？有了清清，今生便没有任何事情值得容瑾后悔了。\n\n\n‌曾经，我爱天下无双的权势，我爱权掌天下的肆意，我爱腥风血雨的畅快。但是…我始终如一的最爱的却只有一个人。\n\n\n‌可怜白骨攒孤冢，尽为将军觅战功。\n\n\n‌今生遇见你，只愿百年好合，平生静好。\n\n\n‌血染江山的画 怎敌你眉间一点朱砂。\n\n\n‌花开了，我就画花；花谢了，我就画我自己；你来了，我当然画你；你走了，我就画一画回忆。\n\n\n‌我洒千斛明珠铺这一路,梦醒时,都归入尘与土。\n\n\n‌十里桃花缘，梦里尘埃落，不似当年美如初。\n\n\n鸿福齐天逢凶化吉？本王不信鬼神，不求苍天。她若殒命，本王便将这天下化为炼狱，让这万里山河为她作祭！\n\n\n华容韶颜，公子无双。少年桀骜，当时峥嵘。\n\n\n愿得韶华刹那，开得满树芳华。如今韶华依旧，芳华却已故。\n\n\n昙花一现，浮游一生，芳华只在一霎那间绽放，握住了便是一生一世，它只为一人而开。\n\n\n上穷碧落下至黄泉，你我生生世世，永不分离！\n\n\n今日容景，以风月立誓，云浅月，吾一生之妻，她死，我死，她亡，我亡，她嫁，我娶。她嫁于他人，我杀天地，灭九州，风月若知我，当以我血祭精魂。\n\n\n倾一世之功，换一世之情，可我想倾尽生命，换生生世世情。\n\n\n我愿倾覆江山，挥笔淋墨，不为慕容先祖，只为你，谁与我争夺，三尺青锋相候。\n\n\n我能看着别人在我眼前死，却不能看你受一点伤。\n\n\n似乎几世轮回，暮然回首，那人就在她身后，太阳升起的地方，驻足等待，从未离去。\n\n\n染尽天下色，不及一人歌。乾坤九州事，生前身后轻。\n\n\n江山太重，我负担不起，我能够负担的，也就是一个你而已。\n\n\n我知道天下事，却独独不知道你的心。\n\n\n女人如花，高挂于枝头，则芬芳艳色，观者仰头钦羡，落于枝尾，则零落飘摇，路人可摘。\n\n\n风华绝代艳天下，玉色倾城倾山河。\n\n\n我此生所求，只是一个她而已。我愿意为她煎熬十年寒暑相思，愿意为她放弃姓氏，愿意为她在大冬天捂暖一株桃花，愿意日日只抱着她入眠。凡是她喜欢的，所求的，我都愿意去为她做。\n\n\n万里江山如画,不及卿之容华。\n\n\n爱入骨，情难绝，三千青丝寸寸雪！\n\n\n输赢又如何？总也要抗争一回。输了，一座孤坟，合葬一培黄土而已，赢了，便是一生相依。\n\n\n生也是我，死也是我。胜固欣然，败也从容。\n\n\n白：我要把你劫走  黑：劫我做什么   白：劫为夫婿。\n\n\n最后一滴酒，敬这一弯孤桥， 世事跌宕多变，唯此桥亘古。\n\n\n若无其事，原来是最狠的报复。    林夕\n\n\n一见钟情，明明是见色起意；\n日久生情，不过是权衡利弊；\n连白头到老，都只是习惯使然。\n\n\n据说那些你一笑就跟着你笑的人，不是傻子就是爱你的人。—安东尼《给不二的情书》\n\n\n在有生的瞬间能遇到你，竟花光所有运气。—林夕《明年今日》\n\n\n如果你认识从前的我，那么你就会原谅现在的我。—张爱玲《倾城之恋》\n\n\n如果你给我的，和你给别人的是一样的，那我就不要了。—三毛\n\n\n有些笑容背后是紧咬牙关的灵魂。—柴静《看见》\n\n\n我将于茫茫人海中访我唯一灵魂之伴侣；得之，我幸；不得，我命。—徐志摩《致梁启超》\n\n\n我行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。—沈从文《湘行散记》\n\n\n你不开心就欺负我好咯，反正我那么喜欢你！—《超能陆战队》\n\n\n差一天 一年 一个时辰 都不算一辈子\n\n\n很多时候 什么都明白 可走不出来\n\n\n树在 山在 大地在 岁月在 我在 你还想要怎样更好的世界   张晓风\n\n\n看着天空  眼泪就不会掉下来\n\n\n到底是人的位置影响了行为 还是行为影响了位置\n\n\n我有所念人 隔在远远乡 我有所感事 结在深深肠\n\n\n‌以后你笑 我跟着你笑 你流啥泪 我替你抹\n\n\n这世界上不是任何事情你情我愿就能成的\n\n\n‌可是很快 所有的这些不愉快都将会烟消云散 留下来的会是温暖而美好的回忆和难分难舍的感情\n\n\n天下女子有情，宁有如杜丽娘者乎！梦其人即病，病即弥连，至手画形容传于世而后死。死三年矣，复能溟莫中求得其所梦者而生。如丽娘者，乃可谓之有情人耳。情不知所起，一往而深，生者可以死，死可以生。生而不可与死，死而不可复生者，皆非情之至也。梦中之情，何必非真，天下岂少梦中之人耶？必因荐枕而成亲，待挂冠而为密者，皆形骸之论也。\n\n","categories":["文艺","句子"]},{"title":"Poem Excerpts","url":"/Beautiful%20Sentence/Poem-Excerpts/","content":"\n何宝莱说:不如我们从头来过。\n\n\n\n山有木兮木有枝，心悦君兮君不知。-《越人歌》\n\n\n春水初生，春林初盛,春风十里，不如你。-冯唐《三十六大》\n\n\n玲珑骰子安红豆，入骨相思知不知?-温庭筠 《南歌子》\n\n\n我行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。-沈从文 《湘行散记》\n\n\n纵然万劫不复，纵然相思入骨，我也待你眉眼如初，岁月如故。一一璎珞玉儿 《没有因为没有所以》\n\n\n上邪，我欲与君相知，长命无绝衰。山无陵，江水为竭。冬雷震震，夏雨雪。天地合，乃敢与君绝。–《上邪》\n\n\n两姓联姻，一堂缔约，良缘永结，匹配同称。看此曰桃花灼灼，宜室宜家，卜他年瓜瓞绵绵，尔昌尔炽。谨以白头之约，书向鸿笺,好将红叶之盟，载明鸳谱。\n\n\n贾宝玉对林黛玉说:“任凭千弱水，我只取-瓢饮。”?\n\n\n愿有岁月可回首，且以深情共白头。:-一《和花和月长少年》\n\n\n青梅枯萎，竹马老去，从此我爱的人都像你。–《竹马翻译官》\n\n\n雨声潺潺，像住在溪边，宁愿天天下雨，以为你是因为下雨不来。一一张爱玲《小团圆》\n\n\n为你，千千万万遍。–《追风筝的人》\n\n\n陌上花开，可缓缓归矣。一一吴越王写给夫人的信\n\n\n斯人若彩虹，遇上方知有。–《怦然心动》\n\n\n还君明珠双泪垂,恨不相逢未嫁时。一一张籍《节妇吟》\n\n\n有生之年，狭路相逢,终不能幸免。一一王菲《流年》\n\n\n此去经年，应是良辰美景虚设。便纵有千种风情,更与何人说。一一柳永《雨霖铃》\n\n\n与我捻熄灯，同我书半生。问我粥可温，同我立黄昏。–改自《墨绪》\n\n\n南风过境/梦至西洲\n“海水梦悠悠，君愁我亦愁。南风知我意，吹梦到西洲”\n――出自 南朝乐府民歌《西洲曲》\n\n\n江上酒/故人倾\n“回头双鬓已星星，谁知江上酒，还与故人倾”\n――出自 南宋·周紫芝《临江仙·送光州曾使君》\n\n\n三山时春/四水常在\n“三山撑四水，四水绕三山，三山四水常在，四水三山四时春”\n――出自 绕口令《三山撑四水》\n\n\n西南风/入君怀\n“愿为西南风，长逝入君怀。君怀良不开，贱妾当何依。”\n――出自 三国·曹植《明月上高楼》\n\n\n因风皱面/为雪白头\n“绿水本无忧，因风皱面。青山原不老，为雪白头。”\n――出自 清·李文甫的一副对联（存疑）\n\n\n双丝网/千千结\n“天不老，情难绝。心似双丝网，中有千千结。”\n――出自 北宋·张先《千秋岁·数声鶗鴂》\n\n\n池鱼/故渊\n“误落尘网中，一去三十年。羁鸟恋旧林，池鱼思故渊。”\n――出自 东晋·陶渊明《归园田居》\n\n\n山有色/水无声\n“远看山有色，近听水无声。春去花还在，人来鸟不惊。”\n――出自 唐·王维《画》\n\n\n枫林晚/二月花\n“远上寒山石径斜，白云生处有人家。停车坐爱枫林晚，霜叶红于二月花。”\n――出自 唐·杜牧《山行》\n\n","categories":["文艺","句子"]},{"title":"What is Special","url":"/Beautiful%20Sentence/What%20is%20Special/","content":"你真特别\n\n所有描写秋天的句子，都不及你特别\n我看过一千个描写秋天的句子，都不及此刻的你特别。\n我看过一千个描写秋天的句子，都不及这个慵懒的夜晚，恰好吹来的风，还有此刻的你。\n","categories":["文艺","句子"]},{"title":"stack","url":"/CS/stack/","content":"聊聊老生常谈的栈\n\n堆栈在计算机科学学科中是重要的数据结构，今天我们就来聊聊栈在计算机中的应用。\n定义\n栈：一种先进后出的数据结构\n什么叫先进后出呢，打个比方：\n现在有一个空桶，你需要将一摞与桶口径大小相同的盘子，放到桶里，以常理来讲，我们需要将这些盘子按照顺序，一个一个的放入桶中摞起来，取出的时候也需要从上到下，依次取出。\n而这个桶，就是我们今天要聊的数据结构：栈，而放入盘子和取出盘子，分别对应了栈的两个基础操作：push、pop，同样的，这两个操作，也只能通过栈顶来进行操作。\n关于栈，还有以下几个基础定义：\n- 栈顶：允许进行操作的一端，相当于例子中桶顶\n- push: 进栈，栈的基础操作，可以将元素放置在栈的顶部，相当于将盘子放入桶的顶端\n- pop：出栈，栈的基础操作，可以将元素从栈顶取出，相当于从桶中取出一个盘子\n计算机中的应用\n关于计算机中的应用，在这里可以举几个例子：\n\nC#中变量的内存分配\n\n在C#中，通过某种方式声明变量的时候：\nint a = 6;int b = 10;\n这时，系统会按照变量的声明顺序，将他们压入栈中。\n当代码块执行结束之后，按照栈先进后出的原则，系统会按照出栈顺序分别对内存进行回收。\n\n多项式的计算\n\n给定一个多项式：[3*(5+1)]/5。\n如果按照人的思维，进行这个多项式计算是一件很简单的事情，而计算机程序则需要借用到今天我们聊到的栈。\n开始计算的时候，计算机程序从左至右按照字符读入这个多项式，\n当遇到右括号((、[)的时候计算机会将当前字符压入栈中，\n当遇到左括号()、])的时候计算机会将当前字符与栈顶元素进行比较，观察是否匹配，\n如果匹配，则将当前括号中的式子进行计算。\n一个简单实现\n#pragma once#ifndef MYSTACK_H#define MYSTACK_H#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class MyStack&#123;public:\tMyStack(int size);\t~MyStack();\tbool stackEmpty();\tbool stackFull();\tvoid clearStack();\tint stackLength();\tvoid push(T element);\tT pop();\tT top();\tvoid stackTraverse();private:\tT* m_pBuffer;\tint m_iSize;\tint m_iTop;&#125;;template &lt;typename T&gt; MyStack&lt;T&gt;::MyStack(int size)&#123;\tm_iSize = size;\tm_pBuffer = new T[size];\tm_iTop = 0;&#125;template &lt;typename T&gt; MyStack&lt;T&gt;::~MyStack()&#123;\tdelete[]m_pBuffer;&#125;template &lt;typename T&gt; bool MyStack&lt;T&gt;::stackEmpty()&#123;\treturn m_iTop == 0;&#125;template &lt;typename T&gt; bool MyStack&lt;T&gt;::stackFull()&#123;\treturn m_iTop == m_iSize;&#125;template &lt;typename T&gt; void MyStack&lt;T&gt;::clearStack()&#123;\tm_iTop = 0;&#125;template &lt;typename T&gt; int MyStack&lt;T&gt;::stackLength()&#123;\treturn m_iTop;&#125;template &lt;typename T&gt; void MyStack&lt;T&gt;::push(T element)&#123;\tif (stackFull())\t&#123;\t\tcout &lt;&lt; &quot;The Stack is Full! Please Pop Something Before You Push Something.&quot; &lt;&lt; endl;\t\treturn;\t&#125;\tm_pBuffer[m_iTop++] = element;&#125;template &lt;typename T&gt; T MyStack&lt;T&gt;::pop()&#123;\tif (stackEmpty())\t&#123;\t\tcout &lt;&lt; &quot;The Stack is Empty! Please Push Something Before You Pop Something.&quot; &lt;&lt; endl;\t\treturn NULL;\t&#125;\treturn m_pBuffer[--m_iTop];&#125;template &lt;typename T&gt; T MyStack&lt;T&gt;::top()&#123;\tif (stackEmpty())\t&#123;\t\tcout &lt;&lt; &quot;The Stack is Empty! Please Push Something.&quot; &lt;&lt; endl;\t\treturn NULL;\t&#125;\tint currentTop = m_iTop - 1;\treturn m_pBuffer[currentTop];&#125;template &lt;typename T&gt; void MyStack&lt;T&gt;::stackTraverse()&#123;\tfor (int i = 0; i &lt; m_iTop; i++)\t&#123;\t\tcout &lt;&lt; m_pBuffer[i] &lt;&lt; endl;\t&#125;&#125;#endif // !MYSTACK_H","categories":["CS","stack"]},{"title":"合成复用原则(Composite Reuse Principle)","url":"/Design%20Pattern/CRP/","content":"尽量使用对象的组合，而不是继承来达到复用的目的，类与类之间的关系应该是has-a而不是is-a。\n优点\n\n降低主类的复杂度\n\n示例\n现有一个银行卡类的设计需求，简单分析后，将代码设计如下：\npublic interface ICard&#123;    string Id &#123; get; set &#125;    void Withdraw();    void Deposit();    void Overdraw();&#125;public class MyCard : ICard&#123;    public void Withdraw()    &#123;        // do something    &#125;    public void Deposit()    &#123;        // do something    &#125;    public void Overdraw()    &#123;        // do something    &#125;&#125;\n如此设计，我们办理的所有卡都将具有这个功能，此时使用了继承关系。为了更灵活的拥有各种功能，可以分别设立储蓄卡和信用卡两种，并拥有银行卡来对衙门进行聚合使用，此时采用了合成复用的原则：\npublic interface ICard&#123;    public string Id &#123; get; set &#125;    public SaveCard saveCard();    public CreditCard creditCard();&#125;public class SaveCard&#123;    public void Withdraw()    &#123;        // do something    &#125;    public void Deposit()    &#123;        // do something    &#125;&#125;public class CreditCard&#123;    public void Overdraw()    &#123;        // do something    &#125;&#125;public class MyCard : ICard&#123;    &#125;","categories":["设计模式"]},{"title":"依赖倒置原则(Dependency Inversion Principle(DIP))","url":"/Design%20Pattern/DIP/","content":"该原则的定义为：1. 上层模块不应该依赖于底层模块，他们应该依赖于抽象。 2. 抽象不应该依赖于细节，细节应该依赖于抽象\n优点\n\n减少类之间的耦合性\n提高系统的稳定性\n降低并行开发引起的风险\n提高代码的可读性和可维护性\n\n难点\n\n设计之初就应该将整体的框架想好，提前抽象出应当抽象的东西\n\n示例\n现有一个输出消息的需求，要求不同设备能输出不同的消息，那么给出如下代码：\npublic class DeviceA&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceA&quot;);    &#125;&#125;public class DeviceB&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceB&quot;);    &#125;&#125;public class ComputerControl()&#123;    public void ConsoleLog(DeviceA device)    &#123;        device.ConsoleLog();    &#125;    public void ConsoleLog(DeviceB device)    &#123;        device.ConsoleLog();    &#125;&#125;\n这样设计的话，设计之初可能没什么大的问题，但随着设备的增加，每次增加设备都要在电脑控制台进行性的实现，使我们的代码变得愈发的臃肿，难以维护，这里可以发现，ComputerControl这个类是一个高级模块，而DeviceA、DeviceB都是细节实现类，这样的设计不符合依赖倒置的设计原则，于是将代码做出如下修改：\npublic interface IConsoleLog&#123;    void ConsoleLog();&#125;public class DeviceA : IConsoleLog&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceA&quot;);    &#125;&#125;public class DeviceB : IConsoleLog&#123;    public void ConsoleLog()    &#123;        Console.WriteLine(&quot;I&#x27;m DeviceB&quot;);    &#125;&#125;public class ComputerControl()&#123;    public void ConsoleLog(IConsoleLog device)    &#123;        device.ConsoleLog();    &#125;&#125;\n将代码修改成这样之后，以后再加设备，仅需增加该设备的具体实现，让他实现ConsoleLog的接口即可，这里让ComputerControl依赖于抽象IConsoleLog，其他的设备依赖于该抽象，以后的拓展和维护变得更加的方便了。\n图例\n\n","categories":["设计模式"]},{"title":"DRY原则(Don't repeat yoursel)","url":"/Design%20Pattern/DRY/","content":"DRY原则是指在编程过程中不写重复的代码，将公共的部分抽象出来，封装成一个基础类，在使用的时候再进行调用。\n优点\n\n降低了代码的耦合度\n提高代码的灵活性、健壮性以及可读性，方便了后期的维护和修改\n\n难点\n\n抽象需要恰到好处，过多的抽象可能会导致简单的代码复杂化\n可能会导致降低代码的可读性\n\n示例\n现有一个根据不同的url获取不同路径的需求，分析后设计代码如下：\npublic string GetBody(string url)&#123;    String body = &quot;&quot;;    if (url.Equals(&quot;/index.html&quot;))     &#123;        body = &quot;./public/index.html&quot;;    &#125;    if (url.Equals(&quot;/css/index.css&quot;))    &#123;        body = &quot;./public/css/index.html&quot;    &#125;    if (url.Equals(&quot;/js/index.js&quot;))    &#123;        body = &quot;./public/js/index.html&quot;;    &#125;    return body;&#125;\n当情况比较多之后，这么一个简单的功能的代码量就会变得非常庞当，而且更麻烦的是维护的过程中，如果文件夹位置改变或者文件名改动，就会牵一发而动全身，如果某个位置漏改了，就会引起程序出错。即便改完所有地方，也是一件挺麻烦的事。所以我对代码进行抽象、修改。修改之后 代码如下：\npublic string GetBodyFunction(url)&#123;    var body = new StringBuilder();    return body.AppendFormat(&quot;./public&#123;0&#125;&quot;,url);&#125;public string GetBody(string url)&#123;    String body = GetBodyFunction(url);    return body;&#125;\n图例\n\n","categories":["设计模式"]},{"title":"接口隔离原则(Interface Segregation Principle(ISP))","url":"/Design%20Pattern/ISP/","content":"通俗的来说，就是一个接口里不要放很多方法，这样会显得这个接口臃肿不堪，接口应当尽量细化，一个接口对应一个功能模块，同时接口里的方法应当尽可能的小，使接口更加轻便灵活。\n优点\n\n避免接口污染\n提高灵活性\n提供定制服务\n实现了高内聚\n\n难点\n\n设计时必须根据实际需要实际考虑，没有一个通用的办法\n\n示例\n举一个很常见的例子，现在有一个需求，我们需要一个接口用来定义美女，给出的要求：美女包括面貌、身材和气质，那么根据需求定义如下接口：\npublic interface IBeauty&#123;    public bool IsLookNice(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity is look nice or not    &#125;    public bool IsNiceFigure(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has nice figure or not    &#125;    public bool GreatTemperament(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has great temperament or not    &#125;&#125;\n看起来代码如此设计并没有什么问题，但是现实生活中不乏有长得一般，但是气质很好的气质美女，那么上面的接口就不再适用，于是我们将代码做如下修改：\npublic interface ILookBeauty&#123;    public bool IsLookNice(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity is look nice or not    &#125;    public bool IsNiceFigure(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has nice figure or not    &#125;&#125;public interface ITemperamentBeauty&#123;    public bool GreatTemperament(beauty beautyEntity)    &#123;        // do some logic judge this beautyEntity has great temperament or not    &#125;&#125;\n然后通过这两个接口的组合，便能完成之前提到的需求。\n图例\n\n","categories":["设计模式"]},{"title":"迪米特法则(Law of Demeter(LD))","url":"/Design%20Pattern/LD/","content":"迪米特法则的意义在于降低类之间的耦合，它要求一个对象应该对其他对象有最少的了解（也就是说，设计的每个类、每个功能点应该相对独立，互相之间不存在或者说很少有依赖关系）。在实践中，通常采用只暴露必须要暴露的方法，来保证迪米特法则，其他一些不必要暴露的方法，全都设置为私有方法，不允许外部类使用和查看。以此降低两个类之间的耦合。\n优点\n\n提高了类的复用性\n降低了类变更的风险\n\n难点\n\n采用该法则应当适度，解耦是有限度的，要根据经验来避免过犹不及。\n\n示例\n现有一个场景，一个男人要煮咖啡，现有两个类，分别是咖啡机和这个男人，代码如下：\npublic class CoffeeMachine&#123;    public void AddCoffeeBean()    &#123;        // do something    &#125;    public void AddWater()    &#123;        // do something    &#125;    public void StartMachine()    &#123;        // do something    &#125;&#125;public class Man&#123;    public void MakeCoffee()    &#123;        CoffeeMachine coffeeMachine = new CoffeeMachine()&#123; &#125;;        coffeeMachine.AddCoffeeBean();        coffeeMachine.AddWater();        coffeeMachine.StartMachine();    &#125;&#125;\n在以上代码中，男人对于咖啡机内部的方法了解过多，其实他并不用关注这些具体的过程，所以将代码进行优化：\npublic class CoffeeMachine&#123;    public void MakeCoffee()    &#123;        AddCoffeeBean();        AddWater();        StartMachine();    &#125;    private void AddCoffeeBean()    &#123;        // do something    &#125;    private void AddWater()    &#123;        // do something    &#125;    private void StartMachine()    &#123;        // do something    &#125;&#125;public class Man&#123;    public void MakeCoffee()    &#123;        CoffeeMachine coffeeMachine = new CoffeeMachine()&#123; &#125;;        coffeeMachine.MakeCoffee();    &#125;&#125;\n这样修改了之后，暴露给男人的接口变少，减少了男人类对咖啡机类的了解，降低了它们之间的耦合。\n","categories":["设计模式"]},{"title":"里氏替换原则(Liskov Substitution Principle(LSP))","url":"/Design%20Pattern/LSP/","content":"里氏替换原则是用来解决当父类代码改变，子类功能也会受到影响的问题。在设计类的时候，如果有继承关系，其子类必须实现父类的所有抽象方法，但是不可以重写父类的非抽象（已实现）方法，子类可以新增自己特有的方法，在实现抽象方法时，其形参必须比父类的形参更为宽松，但返回值子类必须比父类更为严格。（isA）\n优点\n\n增强了程序的健壮性、兼容性\n克服了继承中重写父类造成的可复用性变差的缺点\n降低了代码出错的可能性\n\n难点\n\n\n\n示例\n正方形到底是不是特殊的长方形~\npublic class Rectangle&#123;    private double width &#123;get; set; &#125;    private double height &#123;get; set; &#125;&#125;public class Square&#123;    private double side &#123;get; set; &#125;&#125;\n以此来看的话，正方形和长方形的结构完全不同，看起来正方形不应该是长方形的子类，所以长方形和正方形之间并不符合里氏替换原则，但是，将代码做如下修改：\npublic interface IPolygon&#123;    public double GetWidth();    public double GetHeight();&#125;public class Rectangle : IPolygon&#123;    private double width;    private double height;    public double GetWidth()    &#123;        return width;    &#125;    public void SetWidth(double width)    &#123;        this.width = width;    &#125;    public double GetHeight()    &#123;        return height;    &#125;    public void SetHeight(double height)    &#123;        this.height = height;    &#125;&#125;public class Square : IPolygon&#123;    private double side;    public double GetWidth()    &#123;        return this.GetSide();    &#125;    public void SetWidth(double width)    &#123;        this.SetSide(width);    &#125;    public double GetHeight()    &#123;        return this.GetSide();    &#125;    public void SetHeight(double height)    &#123;        this.SetSide(height);    &#125;    public double GetSide()    &#123;        return side;    &#125;    public void SetSide(double side)    &#123;        this.side = side;    &#125;&#125;\n图例\n\n","categories":["设计模式"]},{"title":"开放封闭原则(Open Closed Principle(OCP))","url":"/Design%20Pattern/OCP/","content":"对于类的设计来说，他应该是可以拓展的，但不应该可以进行修改，也就是说，对拓展是开放的，而对修改是封闭的。对拓展开放，意味着有新的需求或变化时，可以对现有代码进行拓展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以进行独立的工作，而不需要对类进行任何修改。而在设计类的时候要符合这个原则，只有依赖于抽象，实现开放封闭的核心思想就是抽象编程，而不是具体编程，因为抽象相对稳定，让类依赖于固定的抽象，所以对修改是封闭的，而通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过重写方法来改变其固有的行为，实现新的拓展方法，这是实施开放封闭原则的基本思路。\n优点\n\n代码可读性高，可维护性强\n单一类的逻辑简单，复用性强\n\n难点\n\n类的设计要做到完全对修改封闭，几乎是不可能完成的任务，视情况而定，不用强求。\n对设计类的人员要求较高，因为要考虑到以后所有有可能变化的因素，留下接口\n\n示例\n现有一个计算器的设计需求，要求实现加减乘除，最简单的实现：\npublic class Calculator&#123;    public double Add(double numberA,double numberB)    &#123;        return numberA + numberB;    &#125;    public double Minus(double numberA,double numberB)    &#123;        return numberA - numberB;    &#125;    public double Multiply(double numberA,double numberB)    &#123;        return numberA * numberB;    &#125;    public double Divide(double numberA,double numberB)    &#123;        return numberA / numberB;    &#125;&#125;\n这样的设计在使用初期可能会显得并没有什么问题，但如果现在加入了新的算法，将会导致程序员不得不对这个类进行修改，这就违反了我们的设计原则。于是，进行了如下修改：\npublic interface ICalculator&#123;    double GetResult(double numberA, double numberB);&#125;class Add : ICalculator&#123;    public double GetResult(double numberA, double numberB)    &#123;        return numberA + numberB;    &#125;&#125;...class Divide : ICalculator&#123;    public double GetResult(double numberA,double numberB)    &#123;        return numberA / numberB;    &#125;&#125;\n设计一个getResult的接口，需要不同的算法，就对他进行不同的实现，从而实现不对原类进行修改，只进行拓展，从而实现不同的需求，从而满足开放封闭原则。\n图例\n\n","categories":["设计模式"]},{"title":"设计模式","url":"/Design%20Pattern/Overview/","content":"设计模式是编程界的前辈们，根据自己对面向对象程序编码开发的经验所总结出来的、解决特定问题的一系列套路，他并不是语法规定，而是一套用来提高提高代码复用率、可维护性、可读性、稳健性以及安全性的解决方案。\n\n本次学习基于：Design Patterns - Elements of Reusable Object-Oriented Software一书，该书由Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides四个人合著，他们四个人被称为Gang of Four，缩写为Gof。这本书介绍了23中设计模式，就是指GoF的23种设计模式。\n六大原则 SOLID\n所有的设计模式均遵循以下六个基本的设计原则：\n\n单一职责原则：Single responsibility principle(SRP)\n开放封闭原则: Open Closed Principle(OCP)\n里氏替换原则: Liskov Substitution Principle(LSP)\n迪米特法则: Law of Demeter(LD)\n接口隔离原则: Interface Segregation Principle(ISP)\n依赖倒置原则: Dependency Inversion Principle(DIP)\n\n另外，在平时的代码设计中，还涉及到其他的四个原则：\n\nDRY原则: Don’t repeat yourself\nYAGNI原则:  You aren’t gonna need it\n三次原则: Rule of three\n合成复用原则: Composite Reuse Principle\n\n总结\n三大设计模式\nGoF的23种设计模式一般分为三大类\n创建型模式\n\n工厂方法模式\n抽象工厂模式\n单例模式\n创建型模式\n原型模式\n\n结构型模式\n\n适配器模式\n外观模式\n享元模式\n组合模式\n装饰器模式\n代理模式\n桥接模式\n\n行为型模式\n\n策略模式\n状态模式\n职责链模式\n观察者模式\n模板方法模式\n命令模式\n备忘录模式\n迭代器模式\n调停者模式\n解释器模式\n访问者模式\n\n","categories":["设计模式"]},{"title":"三次原则(Rule of three)","url":"/Design%20Pattern/ROT/","content":"这个原则是用来解决DRY和YAGIN原则的矛盾的，就是只有当某个功能出现第三次的时候，才会将其进行抽象。这样，既不会出现太早的抽象化，也不会使代码变得更复杂。\n优点\n\n避免了耗费没必要的抽象化时间\n可以更准确的对某些功能进行抽象化\n\n示例\n对于一个数列来说，两个元素不足以看出规律：\n1 2\n但是当第三个元素出现的时候，其规律就变得清晰了起来：\n1 2 4\n","categories":["设计模式"]},{"title":"单一职责原则(Single responsibility principle(SRP))","url":"/Design%20Pattern/SRP/","content":"在设计一个类的时候，应该只有一个引起他变化的原因，且应只完成一个任务（职责），如果一个类有一个以上的职责，那么这些职责就耦合在了一起，这会导致设计出来的代码不够健壮，当某一个职责发生变化的时候，可能会影响到其他的职责，另外，如果多个职责耦合在一起，将会影响到这个类的复用性。\n优点\n\n降低类的复杂性，单个类只负责单一的职责，逻辑相比较于负责多职责的类简单\n提高类的可读性，提高代码的可维护性\n提高类的复用性\n降低代码变更带来的风险，修改某一个接口的功能的时候，降低该接口对其他接口功能的影响\n\n难点\n\n职责没有一个量化的标准，在划分单个类的职责时，需要从实际出发，以经验为准，对特定的项目进行特定的分析\n\n示例\n假设我现在在做一个学生信息管理系统，现有一个需求，要求提供修改学生基本信息的接口，于是我进行了如下设计：\nbool changeUserInfo(UserEntity student, string changeOption)&#123;    // do something&#125;\n该方法可以将changeOption中需要修改的参数，在函数体中进行逻辑处理，将其修改到student实体中，但是这样带来的问题就是，方法职责不清晰、不单一，较好的设计应该是，如果需要修改用户名，就调用修改用户名的API，需要修改家庭住址，就调用修改家庭住址的API，修改后的代码如下：\nbool changeUserName(string name)&#123;    // do something&#125;bool changeUserAddress(string address)&#123;    // do something&#125;\n如此设计，在后期的维护、修改、重构代码将会变得轻而易举，每个方法的职责清晰明确，开发难度也变低了。\n图例\n\n","categories":["设计模式"]},{"title":"YAGNI原则（You aren't gonna need it）","url":"/Design%20Pattern/YAGNI/","content":"除了最核心的功能，其他功能一概不要部署，这样来加快开发，他背后的指导思想，就是尽可能快，尽可能简单的让软件运行起来。\n优点\n\n开发速度快\n\n难点\n\n如何合理的降低抽象的层级，来实现低复杂度\n如何适度的接受非功能性的需求\n\n","categories":["设计模式"]},{"title":"Summary","url":"/Design%20Pattern/summary/","content":"通过这次对代码设计原则的学习，我了解到了在设计代码的时候，不能总是想到哪就写到哪，在开始写代码之前，需要有一个整体的流程，需要想好那些地方该抽象，那些地方需要冗余，否则，写出来的代码也会很繁琐，不够简洁。在设计代码的时候，既不能一味的追求代码满足全部的设计原则，也不能一点都不顾这些设计原则，要有一个自己拿捏的度，适量的使用这些原则，才能使自己的代码变得更加优美。\n在设计代码的时候，要时刻提醒自己，自己设计的代码一定要满足高内聚、低耦合这两个原则，并在之后的编码过程中进行实践，长此以往，写出来的代码必定不会太差。\n","categories":["设计模式"]},{"title":"MySql","url":"/Docker/MySql/","content":"Mysql 配置\n\n拉取镜像\ndocker pull mysql\n创建容器\ndocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql\n\nname：容器名，此处命名为mysql\ne：配置信息，此处配置mysql的root用户的登陆密码\np：端口映射，此处映射 主机3306端口 到 容器的3306端口\nd：后台运行容器，保证在退出终端后容器继续运行\n\n连接MySql\ndocker exec -it mysql bashmysql -uroot -p123456\n如果容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：\n开放端口：\n$ systemctl status firewalld$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent$ firewall-cmd  --reload\n关闭防火墙：\n$ sudo systemctl stop firewalld需要进入docker本地客户端设置远程访问账号$ sudo docker exec -it mysql bash$ mysql -uroot -p123456mysql&gt; grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;","categories":["Docker","Images"]},{"title":"some-keywords","url":"/Java%20Learn/some-keywords/","content":"一些名词解释\n\n","categories":["Java Learn","Keywords"]},{"title":"spring-learn","url":"/Java%20Learn/spring-learn/","content":"Spring Learning\n\n20210308\n配置了一整天，从安装java开始，安装idea，安装maven，配置maven，为项目添加framework支持，终于完成了hello spring\n\n整体下来，感觉java的设计理念跟C#的设计理念不尽相同，但是还是有一些细微的差别\n对比起之前C#的上手难易程度，我只能说，官方支持是真的牛批！\n","categories":["Java Learn","spring"]},{"title":"wipe","url":"/Phone/wipe/","content":"手机双清，三清，四清等说明\n\n双清:\nDalvik/ART Cache\nCache\n其目的就是清除分区以及数据而已，简称重置手机或恢复出厂。\n三清:\nDalvik/ART Cache\nCache\nData\n刷机前基本上都选择三清！目的是新系统的兼容性达到最佳。\n四清:\nDalvik/ART Cache\nCache\nData\nSystem\n四清针对版本差异过大的！\n因为四清包含system分区，所以不刷入系统无法开机进系统！\n五清:\nDalvik/ART Cache\nCache\nData\nSystem\nInternal Storage（内置储存\n如果选择了内置储存这个选项，那么执行之后手机sd内所有的东西都没了，只能电脑推包或者OTG推包。\n六清:\nDalvik/ART Cache\nCache\nData\nSystem\nInternal Storage（内置储存）\nUSB OTG\n六清清除USB OTG传的升级包文件，一般用不上\n","categories":["刷机","双清"]},{"title":"秦岭 草甸","url":"/Tourism/Caodian%20Qinling/","content":"20210116 秦岭草甸记录\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["旅游","爬山"]},{"title":"嘉午台游记","url":"/Tourism/Jiawu%20Terrace/","content":"20210130 嘉午台记录\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["旅游","爬山"]},{"title":"Tang","url":"/Tourism/Tang/","content":"20210308 团建 温泉\n\n\n\n\n\n","categories":["旅游","团建"]}]